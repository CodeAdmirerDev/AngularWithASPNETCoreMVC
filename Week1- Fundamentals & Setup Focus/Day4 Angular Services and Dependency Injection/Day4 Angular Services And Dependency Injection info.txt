âœ… Day 4 - Angular Services & Dependency Injection: Beginner to Expert (with Explanations)

ğŸŸ¢ Beginner Level

ğŸ§© Concepts to Understand:
What is a service?
What is Dependency Injection?
Singleton pattern in Angular
Why use services?

ğŸ”¸ What is a Service in Angular?
A Service in Angular is a class that holds logic or data that can be shared across components.
Instead of writing the same logic in multiple places, we write it once in a service and inject it wherever needed.

ğŸ” Think of it as:
"A separate helper file where you write logic once and use it anywhere in your app."

ğŸ§  Example Use Cases:
Calling REST APIs
Storing user authentication state
Centralizing business rules
Utility/helper methods

ğŸ”§ Sample Service:
@Injectable({
  providedIn: 'root'
})
export class GreetingService {
  getGreeting(): string {
    return 'Hello from Angular Service!';
  }
}




ğŸ”¸ What is Dependency Injection (DI)?
Dependency Injection is a design pattern Angular uses to provide components with the services they need.

ğŸ” Think of it as:
"Instead of creating the object yourself, Angular gives it to you when needed."

ğŸ“¦ Example:
constructor(private userService: UserService) {}

Here, Angular will:
Create an instance of GreetingService
Provide it to the component
Manage its lifecycle

ğŸŸ¨ No need to write: let greetingService = new GreetingService(); â€” Angular handles it.

ğŸ‘‰ This tells Angular:
â€œHey Angular, give me an instance of UserService for this component.â€


âœ… 3. What is the Singleton Pattern in Angular?
A singleton means only one instance of a service is created and shared across the entire application.

When you use:
@Injectable({ providedIn: 'root' })

Angular will:
Create the service once
Reuse the same instance for all components/services that need it

ğŸ§  Why this is good?
Saves memory
Maintains a shared state
Cleaner code


âœ… 4. Why Use Services in Angular?

Using services in Angular makes your app:
âœ… 1. Modular â€“ Logic is not scattered across components
âœ… 2. Reusable â€“ Same service can be used in multiple places
âœ… 3. Testable â€“ Easier to write unit tests for logic inside services
âœ… 4. Separation of Concerns â€“ Components handle UI; services handle logic/data
âœ… 5. Maintainable â€“ Easier to update/change logic in one place

ğŸ” Example Scenario:
Instead of writing the same HTTP code in 3 components, write it once in a service and use it everywhere.

ğŸ” Quick Summary Table:
Concept	              Description
Service	              A reusable class for logic/data across components
Dependency Injection	Angular provides required instances automatically
Singleton Pattern	    Only one instance of a service exists app-wide (providedIn: 'root')
Why use services?	    For clean, reusable, testable, and modular code


ğŸŸ¡ Intermediate Level

Concepts to Understand:
Injectable services with @Injectable()
Service Injection Scope: providedIn: 'root' vs module-based providers
API calls using HttpClient
Observables and Subscriptions
RxJS basics (map, catchError)


ğŸŸ¡ Intermediate Level â€“ Angular Services & Dependency Injection
âœ… 1. @Injectable() and How Services Become Injectable

ğŸ”¸ @Injectable() and providedIn: 'root'
@Injectable() is a decorator that marks a class as available to be injected.

providedIn: 'root' makes the service a singleton and available throughout the app without registering it in a module.
âœ… Syntax:
import { Injectable } from '@angular/core';
@Injectable({
  providedIn: 'root' // Optional, tells Angular to create one global instance
})
export class UserService {
  constructor() { }
}

ğŸ“Œ This ensures Angular automatically creates one instance of the service and shares it globally.

or

ğŸ”¸ What is @Injectable()?
Itâ€™s a decorator that tells Angular:
â€œThis class might have dependencies. Please manage it and allow it to be injected elsewhere.â€


ğŸ’¡ Why it matters:
If you inject other services into this service, Angular needs to know how to resolve them. @Injectable() handles that.

âœ… 2. Service Injection Scope
ğŸ”¹ providedIn: 'root'
Angular creates one instance for the entire app (singleton).
Most commonly used.

ğŸ”¹ providedIn: 'any'
A new instance for each lazy-loaded module.
Useful for modular apps.

ğŸ”¹ Registering in a Module
Alternatively, register in providers array of a specific module:
@NgModule({
  providers: [UserService]
})
export class AdminModule { }

Service will be available only to that module and its components.

âœ… 3. API Calls using HttpClient

ğŸ”¸ What is HttpClientModule?
Angular uses HttpClientModule to make HTTP calls (GET, POST, etc.) to remote servers (APIs).
Itâ€™s based on Observables and provides powerful features like:
  Streamed data
  Error handling
  Request/response transformations

Angular's HttpClient service (from @angular/common/http) lets you make API requests easily.

ğŸ”§ Setup: Import in app.module.ts
import { HttpClientModule } from '@angular/common/http';

@NgModule({
  imports: [HttpClientModule]
})
export class AppModule {}

ğŸ“„ Sample Service:
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { User } from '../models/user.model';

@Injectable({
  providedIn: 'root'
})
export class UserService {
  private apiUrl = 'https://jsonplaceholder.typicode.com/users';

  constructor(private http: HttpClient) {}

  getUsers(): Observable<User[]> {
    return this.http.get<User[]>(this.apiUrl);
  }
}

âœ… 4. Observables & Subscriptions
Angular uses Observables (from RxJS) for all async operations â€” especially HTTP requests.

ğŸ”¸ Observables in Services
Angular uses RxJS Observables to handle asynchronous operations like HTTP calls.

ğŸ’¡ What is an Observable?
An object that emits values over time (like a stream).

Why Observables?
They are powerful and composable.
You can use operators like map, filter, catchError, etc.
You can unsubscribe to avoid memory leaks.


ğŸ’¡ What is a Subscription?
Listening to that stream and reacting to emitted values.

ğŸ‘‡ Usage Example:
this.userService.getUsers().subscribe(users => {
  this.users = users;
});
â—ï¸Important: Unsubscribe when the component is destroyed to avoid memory leaks (or use async pipe).

âœ… 5. RxJS Basics (map, catchError, etc.)

ğŸ”¹ map â€“ Transforms the data coming from the API
getUsers(): Observable<string[]> {
  return this.http.get<User[]>(this.apiUrl).pipe(
    map(users => users.map(u => u.name)) // return only names
  );
}

ğŸ”¹ catchError â€“ Handles errors gracefully
import { catchError } from 'rxjs/operators';
import { of } from 'rxjs';

getUsers(): Observable<User[]> {
  return this.http.get<User[]>(this.apiUrl).pipe(
    catchError(error => {
      console.error('Error occurred:', error);
      return of([]); // return empty array if error
    })
  );
}

ğŸ” Quick Summary Table

Concept	Description
@Injectable()	      Marks a service as injectable and allows DI
providedIn: 'root'	Makes service a singleton, shared app-wide
HttpClient	        Used for API communication
Observable	        Represents a stream of async data
Subscription	      Listens to the Observable and executes logic on data emit
RxJS map	          Transforms data (e.g., filtering, formatting)
RxJS catchError	    Catches and handles errors from an Observable

âœ… Best Practices for Intermediate Level
âœ… Keep API logic only in services (not in components)
âœ… Always use models/interfaces for typed data
âœ… Use async pipe in templates to avoid manual unsubscribe()
âœ… Use catchError to provide fallback/default values
âœ… Keep services stateless (unless youâ€™re intentionally sharing state)


ğŸ”´ Expert Level

ğŸ§  Concepts to Master:
Injectable Hierarchy (root vs component-level)
Lazy-loaded module service scopes
Interceptors
Abstract Services and Interfaces
Dependency Injection Tokens
Unit Testing Services with HttpTestingController
Use RxJS operators (switchMap, mergeMap, retry, debounceTime, etc.)


ğŸ§  1. Injectable Hierarchy

âœ… Levels of Injection:
providedIn: 'root' â†’ App-wide singleton (most common).
providedIn: 'any' â†’ One instance per lazy-loaded module.

Component providers: [] â†’ New instance for each component.
@Injectable({
  providedIn: 'any'
})
export class ScopedService {}

ğŸ”„ Use providedIn: 'any' for module encapsulation, helpful when services should not share state across the app.

ğŸ§  2. Lazy-loaded Module Service Scope
ğŸ”§ Example:
@NgModule({
  providers: [AdminService]
})
export class AdminModule {}
If AdminModule is lazy-loaded, AdminService will be scoped only to it, allowing you to:
Limit memory usage
Avoid unintended shared state

ğŸ§  3. HTTP Interceptors
Interceptors let you intercept all HTTP requests/responses for:
Adding tokens
Logging
Showing spinners
Handling global errors


ğŸ“„ Create Auth Interceptor:

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const token = 'dummy-token';
    const authReq = req.clone({
      setHeaders: { Authorization: `Bearer ${token}` }
    });
    return next.handle(authReq);
  }
}

ğŸ§© Register Interceptor:

providers: [
  {
    provide: HTTP_INTERCEPTORS,
    useClass: AuthInterceptor,
    multi: true
  }
]
âœ… multi: true allows multiple interceptors.

ğŸ§  4. Abstract Services & Interfaces
You can create abstract base services or use interfaces to enforce structure.

âœ… Abstract Example:
export abstract class BaseService<T> {
  abstract getAll(): Observable<T[]>;
}
Now your services like UserService, ProductService can extend it.

ğŸ§  5. Dependency Injection Tokens
Use InjectionToken when injecting:

Primitive values (like strings, booleans)

Config objects

Multiple implementations of an interface

ğŸ”§ Example:
export const API_URL = new InjectionToken<string>('apiUrl');

@NgModule({
  providers: [
    { provide: API_URL, useValue: 'https://api.example.com' }
  ]
})
export class AppModule {}

constructor(@Inject(API_URL) private apiUrl: string) {}

ğŸ§  6. Unit Testing Services with HttpTestingController
âœ… Setup:
TestBed.configureTestingModule({
  imports: [HttpClientTestingModule],
  providers: [UserService]
});

âœ… Test:
it('should fetch users', () => {
  const dummyUsers = [{ id: 1, name: 'John' }];
  
  service.getUsers().subscribe(users => {
    expect(users).toEqual(dummyUsers);
  });

  const req = httpMock.expectOne('https://jsonplaceholder.typicode.com/users');
  expect(req.request.method).toBe('GET');
  req.flush(dummyUsers);
});

ğŸ§  7. RxJS Operators â€“ Advanced Use Cases

Operator	      Description / Use Case
switchMap	      Cancel previous observable when new value comes (e.g., type-ahead search)
mergeMap	      Run all observables concurrently (e.g., nested calls)
concatMap	      Queue observable calls one after the other
retry	          Automatically retry failed HTTP requests
debounceTime	  Delay emissions (great for input search)
catchError	    Gracefully handle errors

ğŸ”§ Example with switchMap and debounceTime (search API):

this.searchControl.valueChanges.pipe(
  debounceTime(300),
  switchMap(query => this.apiService.search(query))
).subscribe(results => this.results = results);

âœ… Final Summary

Concept	                What You Gain

Injectable hierarchy	  Fine-grained control of service scope
Lazy module DI	        Encapsulation, performance optimization
Interceptors	          Global control over HTTP traffic
Abstract services	      Reusability and consistent contracts
Injection tokens	      Inject configs or multiple implementations safely
HttpTestingController	  Clean & fast unit tests for services
Advanced RxJS	          Reactive, high-performance, real-time UI behavior

ğŸ’¡ Pro Tip
Create a core module for global singletons (e.g., logging, auth), and a shared module for common pipes/components.


ğŸ›¡ Best Practices Summary

Practice	Why?
Use providedIn: 'root'	Automatically tree-shaken and singleton
Use interfaces for API data	Ensures type safety
Keep services stateless if possible	Avoid bugs due to shared state
Use async pipe in template instead of subscribe()	Avoid manual unsubscription
Handle errors using catchError	Improve UX and stability
Write unit tests for services	Ensure service logic is correct
Avoid putting business logic in components	Keep components clean and focused on UI

ğŸš€ Final Suggestion
Want a mini project idea to practice this?

âœ… Build a User Management App

Fetch list of users (GET)
Add a user (POST)
Delete a user (DELETE)

Use interceptors, services, and BehaviorSubject to manage state

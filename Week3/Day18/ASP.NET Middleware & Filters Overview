Here's a detailed guide on ASP.NET Middleware & Filters, focusing on:

Custom Middleware
Exception Handling
Logging

Including:
Explanation & concepts
Step-by-step learning path
Best practices
Sample project code

Day 18: ASP.NET Middleware & Filters

1. Custom Middleware
Middleware in ASP.NET Core is software that's assembled into the application pipeline to handle requests and responses.
It can modify the request on the way in and the response on the way out.
Middleware components are executed in the order they are registered.

How to create custom middleware?
Create a class with a Invoke or InvokeAsync method.
Take HttpContext as a parameter.
Use the RequestDelegate to call the next middleware.
Register your middleware in the pipeline.

2. Exception Handling
Exception handling middleware is used to catch unhandled exceptions across the app in a centralized way.
ASP.NET Core provides built-in UseExceptionHandler middleware.
For development, you can use UseDeveloperExceptionPage for detailed error info.
Custom exception handling middleware can log the error or return custom responses.

3. Logging
Logging records information about application behavior.
ASP.NET Core provides built-in logging via ILogger<T>.
Logs can be written to Console, Debug, files, or external services.
Middleware and filters can utilize logging for diagnostics and audits.

Step-By-Step Process: Beginner to Expert

Beginner
Understand what middleware is and its role in the request pipeline.
Learn to create a simple middleware that logs every request.
Learn built-in middleware like UseStaticFiles, UseRouting, UseEndpoints.
Learn basics of exception handling middleware (UseExceptionHandler).
Explore basic logging with the ILogger interface.

Intermediate
Build custom middleware for specific functionalities (e.g., authentication, custom headers).
Implement a centralized exception handling middleware with custom error responses.
Use dependency injection to inject services into middleware.
Understand middleware ordering importance.
Configure logging providers and filters.
Explore action filters and their use in exception handling and logging.

Advanced
Create complex middleware chains with conditionals and branching.
Implement structured logging and correlation IDs.
Integrate logging with external systems (Seq, ELK stack, Application Insights).
Use filters for cross-cutting concerns in MVC/Web API.
Handle asynchronous middleware and exception flows.
Profile and optimize middleware performance.
Write unit and integration tests for middleware and filters.

Best Practices
Ordering matters: Middleware runs sequentially; place exception handlers near the beginning.
Avoid long blocking calls in middleware; prefer async.
Use middleware for cross-cutting concerns like logging, authentication, and error handling.
Keep middleware simple and focused.
Log enough context (request path, headers, user info) for diagnostics.
Return consistent error responses from your exception middleware.
Use dependency injection to keep middleware testable and loosely coupled.
Donâ€™t expose sensitive exception details in production.
Use filters (ExceptionFilter, ActionFilter) in MVC/Web API when you want to handle logic related to controller actions rather than the entire HTTP pipeline.

Sample Project Code: Middleware, Exception Handling, Logging
Setup
.NET 6/7/8  Web API Template.

Create Middleware, Exception Handling & Logging example.

Sample: Program.cs
var builder = WebApplication.CreateBuilder(args);  

// Add logging configuration (console by default)  
builder.Logging.ClearProviders();  
builder.Logging.AddConsole();  

var app = builder.Build();  

// Use custom exception handler middleware  
app.UseMiddleware<ExceptionHandlingMiddleware>();  

// Use custom logging middleware  
app.UseMiddleware<RequestLoggingMiddleware>();  

app.MapGet("/", () => "Hello World!");  

// Endpoint to test exception handling  
app.MapGet("/error", () =>  
{  
    throw new Exception("Test exception!");  
});  

app.Run();  

Custom Middleware: RequestLoggingMiddleware.cs

public class RequestLoggingMiddleware  
{  
    private readonly RequestDelegate _next;  
    private readonly ILogger<RequestLoggingMiddleware> _logger;  

    public RequestLoggingMiddleware(RequestDelegate next, ILogger<RequestLoggingMiddleware> logger)  
    {  
        _next = next;  
        _logger = logger;  
    }  

    public async Task InvokeAsync(HttpContext context)  
    {  
        _logger.LogInformation("Handling request: {Method} {Path}",   
            context.Request.Method, context.Request.Path);  

        await _next(context);  // Call next middleware  

        _logger.LogInformation("Finished handling request.");  
    }  
}  

Exception Handling Middleware: ExceptionHandlingMiddleware.cs

public class ExceptionHandlingMiddleware  
{  
    private readonly RequestDelegate _next;  
    private readonly ILogger<ExceptionHandlingMiddleware> _logger;  

    public ExceptionHandlingMiddleware(RequestDelegate next, ILogger<ExceptionHandlingMiddleware> logger)  
    {  
        _next = next;  
        _logger = logger;  
    }  

    public async Task InvokeAsync(HttpContext context)  
    {  
        try  
        {  
            await _next(context);  
        }  
        catch (Exception ex)  
        {  
            _logger.LogError(ex, "Unhandled exception caught.");  
            context.Response.StatusCode = 500;  
            context.Response.ContentType = "application/json";  

            var response = new { message = "An unexpected error occurred." };  
            await context.Response.WriteAsJsonAsync(response);  
        }  
    }  
}  

Explanation
RequestLoggingMiddleware logs method and path for every request before and after the request is processed.
ExceptionHandlingMiddleware catches unhandled exceptions, logs the error, and returns a generic JSON error response.
Program.cs wires everything up.

How to Run and Test
Create a new empty ASP.NET Core Web API project (dotnet new web).
Add the two middleware classes.
Replace Program.cs with the sample code.
Run the project.
Navigate to http://localhost:5000/ - should show "Hello World!" and log request.
Navigate to http://localhost:5000/error - triggers exception, logged with JSON error returned.
